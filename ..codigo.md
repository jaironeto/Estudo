# Java 18/03
1. Herança
2. final palavra-chave para uma variavel
3. final palavra-chave para um metodo
4. final palavra-chave para uma classe
5. Declarar, alocar memoria e inicializar um array
6. Outra forma nao usual de declarar array
7. Declarar um array abreviado com inicialização
8. Matriz de mais de uma dimensao com inicialização
9. Concatenar duas string
10. if...else
11. Switch com default
12. while
13. do while
14. for loop
15. for loop aprimorado
16. label e uma break encerrando a label externa
17. continue palavra-chave
18. construtor e encapsulamento
19. declaração simples de um metodo
20. sobrecarga de metodo
21. metodo com um array como parametro
22. sintaxe spreed
23. Instanciação
24. Referenciar um campo/metodo de objeto
25. Método retornando um tipo de referência
26. Usar this em um construtor para resolver problema de identificadores iguais
27. Construtor usando this para chamar outro construtor
28. Membro static
29. campo static final
30. blocos de inicialização estáticos
31. Blocos inicializadores para variáveis ​​de instância
32. Instaniar diretamente uma classe interna
33. classe local
34. classe local acessando membro final do metodo
35. Variavel efetivamente final
36. Interface sendo usado como variavel tipo de uma classe
37. Classe anonima com interface
38. Usando uma enum
39. expressao lambda
40. corpo de expressão lambda com múltiplas instruções dentro das chaves
41. operador de referência de método
42. enum com 2 valores entre ()
43. atributo deprecated
44. atributo override
45. interface e implements 
46. interface extends outra interface
47. interface com default modificador
48. interface com membro static
49. interface com constantes
50. uso de .super. para resolver conflito em interface
51. uso de super() em classe
52. importação estática
53. definir uma string
54. concatenar uma string com tambem uma variavel
55. Classe com construtor, campo, metodo e o metodo main
56. Uso package
57. Inferir o tipo da variavel com var palavra chave
58. Campo static final
59. Interface com metodo default
60. Classe anonima estendendo de uma classe concreta
61. rule switch
62. uso import
63. classe abstract

# Javascript 11/03
1. Definir uma função com uma expressão de função condicionalmente
2. Criar uma função com 'function' construtor
3. Arrow 'function' sem e com abreviações
4. Callback
5. Cadeia de promise com arrow function
6. Chamar uma função
7. closure
8. Expressão de função
9. Função anônima como argumento de outra função
10. Função auto invocada com e sem argumento
11. Função auto invocado com void
12. Função com um iterator e consumir ele
13. Função construtora com campo e metodo
14. Função hoisting
15. Funções de seta
16. Função geradora lidando com sequencias assincrona
17. Lançar uma exeção com um bloco de instrução
18. Acessando um objeto, criando e atribuindo valores as propriedades
19. Matriz de 2 dimensoes sendo com inicialiazação sendo criada e acessada
20. Uso arguments
21. Classe com construtor e um metodo, sendo construido com tres campos direto no construtor
22. Classe com campos e metodos privados
23. try...catch
24. concatenar string com +
25. Uso de get/set com propriedades privadas em classe
26. Uso while
27. Uso throw
28. Uso var, let e const
29. tratamento de erro async/await
30. usar async/await
31. template string
32. typeof
33. for...of
34. switch
35. super e this em classes
36. for..in
37. Herança em classe e override metodos da classe pai
38. do while
39. campos static, metodo static e static block em uma class
40. parametro rest em contrutor de classe
41. objeto literal
42. parametro padrão
43. use de then em promisse, com suas duas funções no Promise construtor
44. declaração de função
45. definir campo/metodo em prototype
46. definir um get/set em um objeto literal
47. definir um get/set posteriomente em um objeto ja criado
48. definir um metodo em uma classe via this
49. definir um metodo normal e abreviado em um objeto literal
50. destruturação em for..of
51. substituir um membros static de uma classe, mas aprimorado com super
52. Objeto literal com prototipo, campo e metodo
53. Definir dinamicamente o nome de um campo em um objeto literal
54. Definir dinamicamente o nome de um campo em uma classe
55. Export default e import
56. Export nomeado e import
57. Exportando todas as funções como um objeto padrão e import
58. Module.exports e require
59. Module.exports e require com desestruturação
60. encadeamento opcional
61. operador de coalescência nula (??)

# C# 11/03
1. Main declarado async
2. Instruição de nivel superior
3. Enum
4. Diretiva using em ação eliminando o uso de System no codigo
5. Namespace com chaves
6. Namespace global
7. Propriedade auto-implementada com required e inicializador de objeto
8. Classe com construtor primario
9. Uso simples de record
10. Uso record com with
11. Uso record mais complicadinho
12. Tipo anonimo
13. Tipo anonimo com um membro mais complexo
14. Matriz com tipo anonimo
15. Mutação com with em tipo anonimo
16. Criando uma struct com new e tambem a partir de um objeto struct ja criado sem usar new
17. Override em metodo virtual
18. Ocultar membro com new
19. Membro ocultado com new sendo convertido para chamar o metodo da classe base que foi ocultado
20. Polimorfismo e selead
21. Usando base palavra chave
22. Usando tupla +1 forma
23. Desconstruindo tupla
24. Desconstruindo tupla com Desconstruct metodo
25. Override metodo toString() object
26. Classe e metodo abstract
27. Classe abstract transformando um metodo virtual em abstract
28. Acabando com a herança virtual de metodo com selead
29. Classe e metodo selead
30. Criar e acessar uma constante
31. Classe abstract
32. Class constante
33. Campo static reandoly
34. Propriedade
35. Sintaxe simples para propriedade somente leitura com membro apto de expressao
36. Propriedade com membro apto de expressao
37. Propriedade auto-implementada
38. Propriedade auto-implementada required
39. Propriedade em interface
40. Acessador propriedade com modificador de acesso
41. Inicializar propriedade auto-implementada
42. Retornar valor por ref
43. Usar uma ref local
44. Metodo async
45. Metodo de extensao
46. Finalizador
47. Um namespace dentro aninhado em outro namespace
48. Main async return
49. Record simples
50. Record com propriedade required
51. Codigo simples e basico com uma class, construtor e propriedades
52. Uso do modificador new em metodos nao virtuais
53. Substituir metodo toString()
54. Abstract herdando de uma classe e transformando um metodo virtual em abstract, para depois quem herdar do metodo abstract dar override
55. switch
56. Campo, propriedade e metodo static
57. Campos const
58. Classe base abstract com propriedade abstract que entao sera override por classes derivadas
59. Nova implementação com new operador sem o uso de virtual
60. Propriedade com acessibilidade diferente
61. Valor retornado por ref
62. ref recebendo uma ref
63. Metodo de extensao com ref e sem ref
64. Metodo de extensao
65. Metodo de extensao para string
66. Usando enum
67. Argumento nomeado e posicional
68. Construtor simples
69. Construtor com : base
70. Sobrecarga de construtor
71. Construtor com : this
72. Classe abstract com construtor sendo acessado quando derivado
73. Construtor static
74. Finalizador
75. As duas sintaxe de inicializador de objeto
76. Tipo aninhado
X Class partial
X Metodos partial
79. literais de cadeia de caracteres entre aspas
80. Literais de cadeia de caracteres textuais
81. Literais de cadeia de caracteres bruta
82. cadeias de caracteres interpoladas
83. literais de cadeia de caracteres bruta com interpolações de cadeia de caracteres
84. Formatação de composição
85. Delegate simples
86. Adicionar e remover um metodo a um delegate
87. Indexador simples
88. Indexador somente leitura e com parametro generico
89. Indexador em uma interface
90. Campos const em uma classe static
91. implementação de interface explícita
92. Uso params
93. Acessando um membro de uma interface herdada, declarando o tipo da interface e usando a variavel da classe
94. Indexador normal
95. Indexador somente leitura
96. Indexador normal com membro apto de expressao
97. Criando uma excessao com uma classe derivada de exception
98. Varios catch para um exception
99. filtros de exceção para adicionar uma expressão booliana a uma cláusula catch
100. Passando um valor por referencia
X 101. Evento
102. Inicializador de objeto e um construtor ao mesmo tempo
103. Classe generica"
104. Metodo generico
105. Usando operator para sobrescrever o operador + da classe
106. Tipo anulavel (?)
107. operador de coalescência nula (??)

# React.js
1. Conceito de usar componente dentro de outros
2. html embutido com fragment
3. Exportando e usando o componente importado
4. Criando uma variavel com o style e entao os usando no componente em style prop
5. Renderização condicional operador tenario e &&
6. Renderizando listas
7. Mantendo componente puro
8. Componente com return abreviado e nao abreviado
9. Codigo limpo, declarando os literals em variaveis e so depois nas props com jsx
10. Usando variaveis javascript dentro do JSX e dentro das tag como texto
11. Usando style elemento css diretamente no html JSX
12. Usando children propriedade passada automaticamente
13. Renderizando itens condicionalmente
14. Renderizando itens condicionalmente e retornando null para nao renderizar
15. Renderizando itens condicionalmente, mas colocando JSX diretamente na variavel
16. Mantendo componente puro
17. Usando nome da className em arquivo css
18. Definindo style diretamente no react
19. Renderização condicional
20. Renderização condicional
21. Responder a um evento
22. Use status
23. Use status autualizando 2 botoes ao mesmo tempo
>24. Exportação e nomeada no mesmo arquivo
25. Respondendo a eventos
26. **** export
27. Atualizando objetos no estado
28. Atualizando matrizes no estado
29. Evento simples
30. Evento simples inline, as duas formas
31. Lendo adereços em manipuladores de eventos
32. Passando manipuladores de eventos como adereços
33. Nomeando adereços do manipulador de eventos
34. Parando a propagação
35. Renderizar

# Typescript.js 
1. adicionando novos campos a uma interface existente com interface
2. adicionando novos campos a uma interface existente com type
3. alias de tipo para nomear um tipo de função
4. alias para um tipo união e depois usar o alias na função
5. aliases de tipo para tipos, objeto e função
6. alias de anotação Tipos de objeto em funções
7. anotações de Tipo de Retorno
8. anotações de tipo em variáveis
9. as duas formas de declarar matrizes
10. asserções de tipo com as do menos especifico para o mais especifico
11. asserções de tipo com as
12. asserções de tipo com <>
13. assinatura de construção
14. assinatura de construção e de metodo
15. assinatura de indice em classes
16. tipo de objeto com uma assinatura de índice
17. Campo reandoly em classe
18. Variavel readonly
19. classe com membro private
20. classe com membro protected
21. classe com membro public
22. classe e membros abstract
23. classe função com uma assinatura de construção, no caso, implements em uma interface com uma
24. classe membros static com modificadores de acesso
25. classes genericas sem construtor
26. classes genericas com construtor
27. combinação de uma função com uma propriedade associada em um tipo, que pode ser usado como parâmetro em uma função normal
28. tsc
29. construtor com campos publicos diretamente inserido
30. declarar uma classe com campos, construtor e metodos
31. declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por uma classe
32. declarar uma função que pode ser chamada com ou sem new, no caso, uma função normal e outra construtora em uma interface. Implementado por um objeto literal
33. definindo um tipo de união em uma função
34. desestruturar tuplas, const com tipo tupla
35. desestruturar tupla como parametro de uma função
36. função com desestruturação de parâmetros
37. Enums
38. especificar o argumento passado para a função génerica
39. estendendo e tambem implementando uma interface
40. estendendo um tipo por meio de interseções
41. estreitamento em tipos de união
42. declare o tipo this no corpo da função
43. extends em classe
44. nao sei
45. função Genérica
46. funções Genéricas com varios parameotros
47. get/set em classes
48. implements em classes
49. inferencia explicita ao chamar uma função génerica
50. interface
51. interface com um tipo generico
52. membros normais e uma assinatura de indice para caso eu precise mais propriedades extra
53. metodos em classes com tipagem em todos os tipos diferentes de membros possiveis
54. operador de Asserção Não Nulo (Postfix !)
55. overloads em construtores de classe
56. parametro de funções opcionais com ? e valor padrão
57. parametro rest em função
58. parâmetros opcionais em retornos de chamada/calback
59. Anotação de tipo explicito de uma função como parametro de uma função

# Express.js
1. Programa mais basico express
2. Servindo arquivos static
3. Chamando next() metodo com mais de uma função de mindlware empilhada na mesma solicitação get
4. Uma matriz de funções de retorno de chamada podem manipular uma rota
5. Uma combinação de funções independentes e matrizes de funções podem manipular uma rota
6. manipuladores de rotas encadeáveis que são definidos usando app.route()
7. Sem texto
8. Carregando uma função em app.use antes de usar get
9. Alterando uma request no app.use antes de usar get
10. Funcao de mindware diretamente no app.use sendo que a função e anonima
11. App.use com um caminho especificado
12. app.use com funções empilhada de mindware

# Sequelize.js
1. Codigo de conexao com o banco de dados
2. Codigo de conexao com o banco de dados configurando logging
3. Definir uma tabela
4. Definir mais de uma tabela
5. Outra forma de declarar um model extendendo de Model, e tambem o erro que ocorre se ocultarmos modelName
6. Outras opções para o sequelize define, interropendo pluralização
7. Extends model com opções, nesse caso interropendo pluralização
8. Definindo o nome da tabela para anular o 'User'
9. Usando sync função para sincronizar
10. Campo com defaultValue
11. Usando build e save
12. Usando User.Create
13. Atualizando um campo e depois usando save
14. Usando update e save
15. Usando Destroy
16. Usando reload

# SQL

# Git

# Electron.js

# [Library] HTML 0/0